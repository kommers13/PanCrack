#ifndef __GRAPH__
#define __GRAPH__

#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <tuple>
#include <algorithm>

static const int inf = 1e9;

using namespace std;

struct TupleHash {
    size_t operator()(const std::tuple<int, int, int>& t) const;
};


class Graph {

    /*
       A: (B, 1), (C, -2)
       B: (A, 1), (C, 3), (D, 5)
       C: (B, 3), (A, -2)
       D: (B, 5), (E, 10), (G, 7)
       E: (D, 10), (F, 0)
       F: (G, 8), (E, 0)
       G: (D, 7), (F, 8)
    */

    // названия вершин
    vector<char> vs;
    // хранение графа в виде неотсортированного map-а
    unordered_map<int, unordered_map<int, int>> graph;
    // для некоторых задачи ориентированный граф может не работать (в данном случае для всех)
    bool undirected;    // true - неориентированный, false - ориентированный

    // является ли граф связным
    // true - DEBUG, пока считаем, что все графы - связные
    bool connected = true;     // true - связный граф, false - несвязный граф

private:

    // создании графа из матрицы смежности
    void create_from_madj(const vector<vector<int>>& madj);

    // создание графа из матрицы смежности из строкового потока
    void construct_from_string_madj(istream& in);

    // создание графа из матрицы инцидентности из строкового потока
    void construct_from_string_incm(istream& in);

    // создание графа из списков смежности из строкового потока

    /* Алгоритм работы construct_from_string_ladj
    Построение графа по строковому потоку введется в два прохода
    В первый раз мы создаем строку, в которой будут только символы чисел, букв и символ точки с запятой
    (;), и не будет никаких специальных символов, помимо символа точки с запятой (;).
    */

    void construct_from_string_ladj(istream& in);   // НЕ РЕАЛИЗОВАН


    // проверка, является ли граф неориентированным
    // он проверяет атрбиут graph на то, чтобы он был НЕОРИЕНТИРОВАННЫМ
    bool is_undirected();

    // проверка, является ли граф связным
    bool is_connected(const vector<vector<int>>& madj); // В АЛГОРИТМЫ

public:

    const unordered_map<int, int>& get_raw_neighbors(int vertex) const {
        return graph.at(vertex);
    }

    // Возвращает вектор отсортированных вершин
    vector<int> get_sorted_neighbors(int vertex) const;

    // возвращает true, если такая вершина есть, иначе false
    bool has_vertex(int vertex) const;

    // нулевой граф
    Graph();

    // граф с n вершинами без ребер
    Graph(const int& n);

    // построение графа при помощи матрицы смежности
    Graph(const vector<vector<int>>& madj);

    // Различные способы задания графов
    // В примере приведен один и тот же граф, только задан тремя разными способами
    // type = 0
    // построение графа при помощи строкового потока с матрицей смежности
    // ввод
    /*

    5
    0   3   inf inf -2
    3   0   5   inf 4
    inf 5   0   10  inf
    inf inf 10  0   6
    -2  4   inf 6   0

    */

    // type = 1
    // построение графа при помощи строкового потока с матрицей инцидентности
    // Данный граф задан при помощи матрицы инцидентности, где столбцы - это пронумерованные ребра,
    // а строки, это пронумерованные вершины
    /*
        r1   r2   r3   r4   r5   r6
    0   1    1    inf  inf  inf  inf
    1   1    inf  1    1    inf  inf
    2   inf  inf  inf  1    inf  1
    3   inf  inf  inf  inf  1    1
    4   inf  1    1    inf  1    inf
    - это пример
    А ее вид при вводе будет выглядеть следующим образом:

    5 6
    3    -2  inf inf inf inf
    3    inf 4   5   inf inf
    inf  inf inf 5   inf 10
    inf  inf inf inf 6   10
    inf  -2  4   inf 6   inf,

    где 5 - количество вершин, 6 - количество ребер
    Значения в столбцах должны быть одинаковыми и их должно быть два, иначе получается,
    что ребро соединяет несколько вершин (больше 2). Если модули значений одинаковые, но значения
    имеют противоположные знаки, то это ориентированный граф (нам они не нужны)
    */

    // type = 2
    // построение графа при помощи строкового потока со списками смежности
    // Данный граф задан списками смежности
    /*

    0: (1, 3), (4, -2);
    1: (0, 3), (2, 5), (4, 4);
    2: (1, 5), (3, 10);
    3: (2, 10), (4, 6);
    4: (0, -2), (1, 4), (3, 6);

    Пользователь может вводить данные о графе без всех знаков препинания, кроме точки с запятой,
    так как программа узнает о новой строке через ";". Пример:

    В таком виде программа будет считать в строке первый, второй, четвертый и следующие четные записи
    названиями вершин, а символы третьи, пятые и следующие нечетные - весами эти вершин.
    0: (1, 3), (4, -2);
    1: (0, 3), (2, 5), (4, 4);
    2: (1, 5), (3, 10);
    3: (2, 10), (4, 6);
    4: (0, -2), (1, 4), (3, 6);

    Здесь вершины будут иметь имена 0, 1, 2, 3 и 4 соответственно.
    Пример:

    0 1 3 4 -2;
    1 0 3 2 5 4 4;
    2 1 5 3 10;
    3 2 10 4 6;
    4 0 -2 1 4 3 6

    В каждой строке должно быть нечетное количество чисел, если оно четное, то программа выбросит
    исключение, так как не будет хватать веса.

    Можно вводить при помощи символов только латинского алфавита (и строчными, и прописными).
    Здесь вершины будут иметь имена T, Y, H, J и E соответственно.
    Пример:

    T Y 3 E -2;
    Y T 3 H 5 E 4;
    H Y 5 J 10;
    J H 10 E 6;
    E T -2 Y 4 J 6

    Две частые ошибки, которые могут возникать - это случайное создание ориентированного графа и интерпретация
    значения вершины как веса, особенно если вершина обозначена буквой
    */

    // istream является предком и stringstream и ifstream
    Graph(const int& type, istream& in);

    // добавить вершину
    void add_vertex(const char& letter = 'A');

    // удалить вершину по номеру
    // если такой нет, то выброситься исключение
    void delete_vertex(int num);

    // добавить ребро
    // v1, v2 - вершины, которые будут соединяться ребрами
    // w - вес ребра
    // нумерация вершин начинается с 0
    void add_edge(int v1, int v2, int w);

    // удалить ребро по вершинам, которые его соединяют
    // если ребро не существует, то выбросится исключение
    void delete_edge(int v1, int v2);           // НЕ РЕАЛИЗОВАН

    // проверка, является ли граф деревом
    bool is_tree() const;       // НЕ РЕАЛИЗОВАН    // В АЛГОРИТМЫ

    // GETTERS
    unordered_map<int, unordered_map<int, int>> get_graph() const;

    // является ли граф неориентированным или нет
    bool get_undirected() const;

    // tuple<int, int, int> - v1, v2, w
    // множество всех ребер графа
    unordered_set<tuple<int, int, int>, TupleHash> get_edges() const;

    // количество ребер
    int get_cnt_edges() const;

    // количество вершин
    size_t get_cnt_vertexes() const;

    // степень вершины v (номер вершины) графа
    // если такой вершины нет, возникнет исключение
    int get_v_degree(int v) const;

    // OPERATORS
    // сравнение графов
    bool operator==(const Graph& other) const;

    // вернуть все смежные вершины и веса
    // в виде unordered_map
    // если такой вершины не существует, то будет исключение
    unordered_map<int, int> operator[](const int& v) const;

    // вывод графа на консоль
    void print();

};

#endif // __GRAPH__
